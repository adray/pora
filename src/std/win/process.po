namespace std
{
    struct process {
        u8* name;
        u32 len;
        u32 pid;
    }

    struct process_list {
        process process;
        process_list* next;
    }

    static u32 findProcesses(process_list* processes) {
        i32 error;
        i64 handle = CreateToolhelp32Snapshot((i32)2, (i32)0);
        if (handle == 0) {
            error = GetLastError();
            return (u32)0;
        }
        PROCESSENTRY32 entry;
        entry.dwSize = (i32) sizeof(PROCESSENTRY32);
        boolean ok = Process32First(handle, &entry);
        if (ok == false) {
            error = GetLastError();
            return (u32)0;
        }

        i64 heap = GetProcessHeap();
        i64 index = 0;
        process_list* list = processes;

        while (ok){
            process* p = &list.process;

            u64 size = (u64)strlen((u8*)entry.szExeFile, (u32)128);
            p.name = HeapAlloc(heap, (i32)0, size+(u64)1);
            p.len = (u32)size+(u32)1;
            p.pid = (u32)entry.th32ProcessID;

            u8* str = p.name;
            u8[] arr = (u8[0])str;
            for (i64 i = 0; i < (i64)size; i+=1) {
                arr[i] = entry.szExeFile[i];
            }
            arr[(i64)size] = 0b;
            index += 1;
            ok = Process32Next(handle, &entry);

            process_list* next = new process_list();
            list.next = next;
            list = next;
        }

        return (u32)index;
    }

    static void freeProcesses(process_list* processes) {
        i64 heap = GetProcessHeap();
        while (processes.next != null) {
            process_list* next = processes.next;
            HeapFree(heap, (i32)0, next.process.name);
            // delete processes;
            processes = next;
        }
    }
}
