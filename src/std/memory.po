namespace std
{
    struct typeAllocChunk
    {
        u32 freeCount;
        u32 bumpIndex;
        u8* data;
        typeAllocChunk* next;
        typeAlloc* owner;
    }

    struct typeAlloc
    {
        u64 size;
        u64 slotsPerChunk;
        typeAllocChunk* chunks;
    }
    
    class typeAllocList
    {
        private typeAlloc* _data;
        private u64 _capacity;
        private i64 _heap;
        
        void init(i64 heap);
        void reserve(u64 capacity);
        typeAlloc* get(u64 typeId);
        i64 getHeap();
    }
    
    i64 typeAllocList::getHeap() {
        return _heap;
    }
    
    void typeAllocList::init(i64 heap, u64 capacity) {
        _heap = heap;
        _data = (typeAlloc*)null;
        _capacity = (u64)0;
        reserve(capacity);
    }
    
    void typeAllocList::reserve(u64 capacity) {
        typeAlloc* data = (typeAlloc*)HeapAlloc(_heap, (i32)0, sizeof(typeAlloc*) * capacity);
        if (_capacity > (u64)0 && _data != null) {
            CopyMemory((u8*)data, (u8*)_data, sizeof(typeAlloc*) * _capacity);
            HeapFree(_heap, (i32)0, (u8*)_data);
        }
        _data = data;
        _capacity = capacity;
    }
    
    typeAlloc* typeAllocList::get(u64 typeId) {
        if (typeId >= _capacity) {
            u64 newCapacity = _capacity * (u64)2;
            if (newCapacity < typeId) {
                newCapacity = typeId;
            }
            reserve(newCapacity);
        }
        
        typeAlloc[] data = (typeAlloc[1])_data;
        return &data[(i64)typeId];
    }

    struct memory
    {
        i64 heap;           // The heap to allocate upon
        typeAllocList al;   // A list of type allocators
    }

    static memory* mem;

    static void initializeMemory() {        
        i64 heap = GetProcessHeap();
        mem = (memory*)HeapAlloc(heap, (i32)0, sizeof(memory));
        mem.heap = heap;
        mem.al.init(heap, (u64)128);
        //print_64(mem.al.getHeap());
    }
    
    static u8* malloc(u64 numBytes) {
        if (mem == null) {
            return (u8*)null;
        }
        
        return HeapAlloc(mem.heap, (i32)0, numBytes);
    }
    
    static void free(u8* bytes) {
        if (mem == null ||
            bytes == null) {
            return;
        }
        
        HeapFree(mem.heap, (i32)0, bytes);
    }

    static u8* malloc2(u64 numBytes, u64 typeId) {
        if (mem == null) {
            return (u8*)null;
        }

        u8* bytes;
        u64 limit = (u64)(256*1024);
        if (numBytes <= limit) {
            // Here we cache it and we won't free it, only mark it.
            bytes = HeapAlloc(mem.heap, (i32)0, limit);
            
        } else {
            // No caching apply the memory directly.
            bytes = HeapAlloc(mem.heap, (i32)0, numBytes);
        }

        if (numBytes <= (u64)248)  {
            // Small memory allocation
            
        }
        else
        {
            // Large memory allocation
        }

        return bytes;
    }
}
